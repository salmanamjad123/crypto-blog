# Database Structure & Data Flow

## âœ… Fixed Issues (January 27, 2026)

### Critical Path Mismatch - RESOLVED

**Problem:** There was an inconsistency between where posts were saved vs. where they were fetched from.

**Solution:** Standardized everything to use a **flat structure**.

---

## ğŸ—„ï¸ Firestore Database Structure

```
Firestore Database (crypto-blog-7fc3b)
â””â”€â”€ posts (collection)
    â”œâ”€â”€ [document-id-1]
    â”‚   â”œâ”€â”€ title: string
    â”‚   â”œâ”€â”€ category: "blogs" | "news"
    â”‚   â”œâ”€â”€ content: ContentBlock[]
    â”‚   â”œâ”€â”€ createdAt: Timestamp
    â”‚   â””â”€â”€ updatedAt?: Timestamp
    â”œâ”€â”€ [document-id-2]
    â””â”€â”€ [document-id-3]
```

### Document Schema

```typescript
interface Post {
  title: string;
  category: "blogs" | "news";
  content: ContentBlock[];
  createdAt: Date | Timestamp;
  updatedAt?: Date | Timestamp;
}

interface ContentBlock {
  id: number;
  type: "h1" | "h2" | "h3" | "p" | "textarea" | "button" | "image";
  content: string;
  link?: string;  // For buttons
  src?: string;   // For images
}
```

---

## ğŸ’¾ Writing Data (Creating/Updating Posts)

### Create Posts

**Methods:**
1. **Dashboard Forms** (Primary method)
   - `CreatePostForm.tsx` â†’ Creates blogs
   - `CreateNewsForm.tsx` â†’ Creates news

**Code:**
```typescript
const blogPost = {
  title,
  category: "blogs", // or "news"
  content: blocks,
  createdAt: new Date(),
};

await addDoc(collection(db, 'posts'), blogPost);
```

2. **API Route** (Alternative method)
   - `POST /api/save-post`
   - Accepts: `{ title, category, content }`
   - Saves to: `posts/[auto-generated-id]`

**Code:**
```typescript
const post = {
  title,
  category,
  content,
  createdAt: new Date().toISOString(),
};

const docRef = await addDoc(collection(db, 'posts'), post);
```

### Update Posts

**Edit Pages:**
- `/dashboard/edit-blog/[slug]` â†’ Edit blogs
- `/dashboard/edit-news/[slug]` â†’ Edit news

**Code:**
```typescript
const docRef = doc(db, 'posts', slug);
await updateDoc(docRef, {
  title,
  content: blocks,
  updatedAt: new Date(),
});
```

### Delete Posts

**Manage Pages:**
- `ManageBlogs.tsx`
- `ManageNews.tsx`

**Code:**
```typescript
await deleteDoc(doc(db, 'posts', postId));
```

---

## ğŸ“– Reading Data (Fetching Posts)

### Method 1: Fetch All Posts by Category (Direct Firestore)

**Used in:**
- Homepage (`/`)
- Blogs listing (`/blogs`)
- News listing (`/news`)
- Dashboard manage pages

**Code:**
```typescript
const q = query(
  collection(db, 'posts'), 
  where('category', '==', 'blogs') // or 'news'
);
const querySnapshot = await getDocs(q);
const posts = querySnapshot.docs.map(doc => ({
  id: doc.id,
  ...doc.data(),
}));
```

### Method 2: Fetch Single Post (Direct Firestore)

**Used in:**
- Individual blog pages (`/blogs/[slug]`)
- Individual news pages (`/news/[slug]`)
- Edit pages

**Code:**
```typescript
const docRef = doc(db, 'posts', slug);
const docSnap = await getDoc(docRef);
if (docSnap.exists()) {
  const post = docSnap.data();
}
```

### Method 3: API Routes (Alternative)

**Available endpoints:**
- `GET /api/posts?category=blogs` â†’ Get all blogs
- `GET /api/posts?category=news` â†’ Get all news
- `GET /api/posts` â†’ Get all posts
- `GET /api/get-post/[category]/[slug]` â†’ Get single post with category validation

---

## ğŸ”„ Complete Data Flow

### Creating a New Blog Post

```
User fills form in Dashboard
    â†“
CreatePostForm.tsx
    â†“
addDoc(collection(db, 'posts'), {...})
    â†“
Firestore: posts/[auto-id]
    â†“
Success! Redirects to /dashboard
```

### Viewing Blog Posts

```
User visits /blogs
    â†“
blogs/page.tsx
    â†“
query(collection(db, 'posts'), where('category', '==', 'blogs'))
    â†“
Firestore returns matching documents
    â†“
Display in grid layout
```

### Viewing Single Blog Post

```
User clicks "Read More"
    â†“
Navigate to /blogs/[id]
    â†“
blogs/[slug]/page.tsx
    â†“
doc(db, 'posts', slug)
    â†“
Firestore returns document
    â†“
Render content blocks dynamically
```

### Editing a Blog Post

```
User clicks "Edit" in Dashboard
    â†“
Navigate to /dashboard/edit-blog/[id]
    â†“
Fetch existing post data
    â†“
User modifies content
    â†“
updateDoc(doc(db, 'posts', id), {...})
    â†“
Firestore updates document
    â†“
Success!
```

---

## ğŸ¯ Key Points

1. **Single Collection:** All posts (blogs and news) are in the `posts` collection
2. **Category Field:** Each post has a `category` field to distinguish between "blogs" and "news"
3. **Flat Structure:** No nested subcollections (posts/category/articles)
4. **Document IDs:** Auto-generated by Firestore (used as slugs in URLs)
5. **Content Blocks:** Posts use a flexible content block system supporting multiple content types
6. **Timestamps:** Posts include `createdAt` and optionally `updatedAt` fields

---

## ğŸ”§ Files Modified (Jan 27, 2026)

1. âœ… `src/app/api/save-post/route.ts`
   - Fixed: Now saves to `posts/` instead of `posts/category/articles/`
   - Added: `category` field to post data
   - Added: `createdAt` timestamp

2. âœ… `src/app/api/get-post/[category]/[slug]/route.ts`
   - Fixed: Now fetches from `posts/[slug]` instead of `posts/category/articles/slug`
   - Added: Category validation for security

---

## ğŸ“ Notes

- All other files were already using the correct flat structure
- No migration needed for existing data (assumes data was already in flat structure)
- If you have old data in nested structure, you'll need to migrate it manually
